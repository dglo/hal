#ifndef DOM_MB_FPGA_SIMUL_INCLUDE
#define DOM_MB_FPGA_SIMUL_INCLUDE

/**
 * \file DOM_MB_fpga.h
 *
 * $Revision: 1.1.1.12 $
 * $Author: arthur $
 * $Date: 2006-06-27 21:55:59 $
 *
 * \b Usage:
 * \code
#include "hal/DOM_MB_fpga.h"
 * \endcode
 *
 * DOM main board hardware access library interface
 *
 */
//#include "hal/DOM_MB_types.h"

/**
 * readout interface stopped state
 *
 */
#define READOUT_STATE_STOPPED 0

/**
 * readout interface running state
 *
 */
#define READOUT_STATE_RUNNING 1

/**
 * readout interface paused state
 *
 */
#define READOUT_STATE_PAUSED 2

/**
 * maximum byte length of FPGA generated event
 *
 */
#define BUFFER_ELEMENT_LEN 2048

/**
 * set readout simulation to pause once buffer is filled
 *
 */
#define READOUT_FILL_ONCE 0

/**
 * set readout simulation to wrap at end of buffer
 *
 */
#define READOUT_WRAP 1

/**
 * initialize readout buffer interface 
 *
 * \param baseAddr base address of buffer memory region
 * \param mask bit mask to indicate length of memory buffer
 */
void
halInitReadoutIface( UBYTE *baseAddr, int mask);

/**
 * reset readout buffer interface
 *
 */
void
halResetReadoutIface(void);

/**
 * get current readout buffer fill index
 *
 * \return index index to next available region in readout buffer memory 
 */
ULONG
halGetReadoutIndex(void);

/**
 * get current readout event fill index
 *
 * \return index index of next available region in readout buffer memory
 */
ULONG
halGetReadoutEventIndex(void);

/**
 * get size of buffer element generated by fpga
 *
 * \return len byte length of fpga event buffer
 */
int
halGetBufferElementLen(void);

/**
 * get fpga data engine mask
 *
 * \return mask fpga data engine mask
 */
int
halGetBufferMask(void);

/**
 * get readout buffer memory mask. Indicates total size of local buffer
 * memory.  Buffer length must be power of two minus one, e.g. 4095.
 *
 * \param mask int bit mask representing length of buffer
 */
int
halGetReadoutMemoryMask(void);

/**
 * disable readout interface
 *
 */
void
halDisableReadoutIface(void);

/**
 * enable readout interface
 *
 */
void
halEnableReadoutIface(void);

/**
 * test if readout interface is enabled
 *
 * \return boolean true if readout interface is enabled
 */
BOOLEAN
halIsReadoutIfaceEnabled(void);

/**
 * set readout interface to fill once then stall
 *
 */
void
halSetReadoutIfaceFillOnce(void);

/**
 * set readout interface to wrap around
 *
 */
void
halSetReadoutIfaceWrap(void);

/**
 * instruct readout interface to resume
 *
 */
void
halResumeReadoutIface(void);

/**
 * get current readout interface state
 *
 * \return state integer value representing readout interface state
 */
int
halGetReadoutIfaceState(void);

/**
 * init the readout interface simulation routines
 * (only used for simulated FPGA operations)
 *
 * \param mutex pointer to mutex to be used by simulation code
 */
void
halSimulInitReadoutIface(pthread_mutex_t *mutex);

/**
 * increment readout interface buffer index for FPGA simulation
 * (only used for simulated FPGA operation)
 *
 */
void
halSimulIncReadoutIndex(void);

/**
 * get next buffer memory address to be filled by FPGA simulation
 * (only used for simulated FPGA operation)
 *
 * \return address address of next byte to be filled by FPGA simulation
 */
UBYTE *
halSimulGetCurReadoutIfaceAddr(void);

/**
 * get address that corresponds to a particular event index
 *
 * \param index ULONG index of event
 * \return addr *UBYTE of event
 */
UBYTE *
halGetReadoutIfaceAddr(ULONG index);
#endif











